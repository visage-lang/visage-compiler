/*
 * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4 of the JavaFX parser grammar.
//
// @author Jim Idle
//
// Version 4 of the grammar reverts to a spearate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// JavafxTree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar ref;

options { 

	// Rather than embed parser oriented Java code in this grammar, just to override
	// methods in the ANTLR base recognizer and derviative classes, we
	// instruct ANTLR to generate a class which is dervied from our own
	// super class. The super class is where we embody any code that does
	// not require direct access to the methods generated 
	// to implement the parser. Hence for instance this is where the 
	// JavafxTreeMaker lives.
	//
	superClass 	= AbstractGeneratedParserV4; 

	// Import the token vocabulary, generated by the
	// lexer grammar analysis.
	//
	tokenVocab	= v4Lexer;
}

// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package com.sun.tools.javafx.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.javac.tree.*;
import com.sun.tools.javafx.tree.*;
import com.sun.javafx.api.tree.*;

import com.sun.tools.javac.util.*;
import com.sun.tools.javafx.util.MsgSym;

import com.sun.tools.javac.code.*;
import com.sun.tools.javafx.code.JavafxFlags;
import static com.sun.tools.javac.util.ListBuffer.lb;
import com.sun.javafx.api.JavafxBindStatus;

import static com.sun.javafx.api.JavafxBindStatus.*;

}


 

script

	:  pd=packageDecl si=scriptItems 
	
		{
			// Construct the JavFX AST
			//
			$result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment);	// Add any detected documentation comment
            
   			// Set tree span and endpoint map (if required).
        	//
        	$result.pos = rPos;
        	endPos($result); 
        	
        	// Pass on the documentation comments and the endpos map
        	//
        	$result.docComments 	= docComments;
        	$result.endPositions	= endPositions;
		}

		EOF 	// Forces parser to consume entire token stream or error out
    ;
    

packageDecl
    : PACKAGE qualifiedName SEMI
    
    		{ $value = $qualifiedName.value; }
    		
    | // No package specified
    
    		{ $value = null; }
	;
	
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

	
	returns [ListBuffer<JFXTree> items = new ListBuffer<JFXTree>()] // This rule builds a list of JFXTree, which is used 
																	// by the caller to build the actual AST.
																	//
	:
		(
			  // Certain script members may be prefixed with modifiers
			  // such as 'public'. We allow the parser to first consume 
			  // all modifier keywords, regardless of whether this is a 
			  // valid modifier for the upcoming declaration. Whether it is
			  // valid or not is a matter for semantic checks to decide.
			  //
			  // Script level variable declarations can conflict with
			  // local variable declarations (which do not allow modifiers
			  // and are encapsulated in the expression rule, which is called
			  // by the statement rule. Hence we must special case it here
			  // unless we want to pass around status to all our rules.
			  // The predicate is a small one and passes or fails quickly.
			  //
			  (modifiers (VAR|DEF|ATTRIBUTE|CLASS|FUNCTION))=>
			  	m1=modifiers
				(
					  c=classDefinition			[$m1.mods]
					  
					 		{ 
								$items.append($c.value); 
							}
							
					| v=variableDeclaration 	[$m1.mods] 
					
							{ 
								$items.append($v.value); 
							}
							
					| f=functionDefinition    	[$m1.mods]
					

					 		{ 
								$items.append($f.value); 
							}
				)
				
			| i=importDecl
			
				{ 
					$items.append($i.value); 
				}
			
			| s=expression
			
				{ 
					$items.append($s.value); 
				}
			
			| SEMI
		)*
	;

// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the smeantics of the modifiers.
//
modifiers

	returns [JFXModifiers mods]	// Constructs and returns a specialized modifer node

@init {

	// The flags we build up for the AST
	//
	long	flags 	= 0;
	
	// The start character position for this AST
	//
	int   	cPos		= pos();
}

	: 	(	
			mf=modifierFlag
			
			{
				// Or in the newly discovered modifier
				//
				flags	|= $mf.flag;
			}
	
		)*
		
		{
			// Build the modifier flags (just as empty if we did not pick any up)
			//
			$mods = F.at(cPos).Modifiers(flags);
			
			// Tree span
			//
			endPos($mods);
		}
	;

// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

	returns [long flag]
	
	: ABSTRACT			{ $flag = Flags.ABSTRACT;				}
	| BOUND				{ $flag = JavafxFlags.BOUND;			}
	| OVERRIDE			{ $flag = JavafxFlags.OVERRIDE;			}
	| PACKAGE			{ $flag = JavafxFlags.PACKAGE_ACCESS;	}
	| PROTECTED			{ $flag = Flags.PROTECTED;				}
	| PUBLIC			{ $flag = Flags.PUBLIC;					}
	| PUBLIC_READ   	{ $flag = JavafxFlags.PUBLIC_READ;		}
	| PUBLIC_INIT		{ $flag = JavafxFlags.PUBLIC_INIT;		}
	;

// -----------------	
// Import statement.
// Include definitions from an external source
//
importDecl

	returns [JFXTree value] // The import declaration is built as a generic JFXTree

 	: IMPORT importId
 	
 		{
 			// AST construction
 			$value = F.at(pos($IMPORT)).Import($importId.pid);
 			
 			// AST span

 			//
			endPos($value);
 		}
	;
	
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

	returns [JFXExpression pid]	// Qualified names are built as expression trees

 	: i1=identifier
 		{
 			$pid = $i1.value;
 		}
		( 
			d1=DOT n2=name
		
				{
					$pid = F.at($n2.pos).Select($pid, $n2.value);
                    endPos($pid);
				}
		)* 
        ( 
        	DOT STAR
        	
        		{
					$pid = F.at($n2.pos).Select($pid, names.asterisk);
                    endPos($pid);
				}
        )?  
	;
	
classDefinition 
	: modifiers 'class' name superclasses 
		'{' 
			 (
		        classMember 
		      | ';'
	         )* 
		'}'
	;
	
superclasses 
	: 'extends' typeName
           ( 
           	',' typeName 
           )*
           
	| // Upsilon - this class inherits no other types so the list will be empty
	;
		  					
classMember
	: functionDefinition
	| variableDeclaration	
	| variableOverrideDeclaration	
	| initBlock
	| postinitBlock
	;


// ----------
// Functions.
// While funcitnos can be declared at any level, their syntax is the same.
// As always, the semantic pass of the JFX tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition 
	: modifiers 'function' name formalParameters typeSpecifier 
		(block)?

	;

variableOverrideDeclaration
	: 'override' 'var' name ('=' initializingExpression)? onReplaceClause?
	;

// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initBlock
	: 'init' block
	;

// Post initialization.
// Parse the post initialization block and produce the AST
//
postinitBlock
	: 'postinit' block
	;
	
variableDeclaration 
	: modifiers (('def' )   | ( 'var' ) ) name typeSpecifier 

        (
            '=' initializingExpression
        )? 
        
        (
            onReplaceClause
        )?
	;
	
// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters
	: '(' 
	
		(
			fp1=formalParameter 
	
			(
				',' fp2=formalParameter
			)*  
		)?
			
	  ')'
	;
	
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

	: name typeSpecifier
	;

block 
	: '{' 
	
		(
			expression
				
			| ';'
	   )*
	
	  '}'
	;

// -----------
// statements.
// Parse the set of elments that are viewed as programmig statements. Note
// that this includes expressions which are considered statements.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, whether this is optional, or whether this is just
// not required (such as if () {} ).
//
expression 
	: insert	
	| delete	
 	| while		
	| break
	| continue
    | throw	   
    | return 		
    | try			
    | valueExpression (';')?						
    ;
  
break
	:	'break'   ';'
	;
continue
	:	'continue'  	 ';'
	;
// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

	
	: 'on' 'replace' name? 
	
		(
			  ('[' name '..' name ']')?
			 
				 '=' name
		)? 
		block
		;
	
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

	returns [JFXVar var]	// Returns a JFXVar tree node

    : paramName
    	{
    		{ $var = $paramName.var; }
    	}
    	
    |	{ $var = null; }
    ;

// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

	returns [JFXVar var]	// Returns a JFXVar tree node

	: name
		{
    		{ 
    			$var = F.at($name.pos).Param($name.value, F.TypeUnknown()); 
    			endPos($var);
    		}
    	}
	;
	
    
// The ways in which a variable can be declared
//
variableLabel 
	
	returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
	
	: VAR			{ $modifiers = 0L; $pos = pos($VAR); }
	| DEF			{ $modifiers = JavafxFlags.IS_DEF; $pos = pos($DEF); }
	| ATTRIBUTE		{ $modifiers = 0L; $pos = pos($ATTRIBUTE); log.warning(pos($ATTRIBUTE), "javafx.not.supported.attribute"); }
	;

// ------	
// Throw.
// Parse the standard exception throwing mechanism.
//
throw

	returns [JFXExpression value]	// Returns the JFX Expression tree representing what we must throw

	: THROW valueExpression ((SEMI)=>SEMI)?
	
		{ 
			// AST for the thrown expression
			//
			$value = F.at(pos($THROW)).Throw($valueExpression.value);
			
			// Tree span
			//
			endPos($value);
		}
	;

// ---------------
// While statement
//
while
	: 'while' '(' valueExpression ')' 
	expression
	;

// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insert  
	
	returns [JFXExpression value]	// All steatemetns return a JFX expression tree

	: INSERT elem=valueExpression
		(
			  INTO eseq=valueExpression
			  
			  	{
			  		// Form 1, INTO
			  		//
					$value = F.at(pos($INSERT)).SequenceInsert($eseq.value, $elem.value, null, false);
			  	}
			  	
			| BEFORE isfi=indexedSequenceForInsert
			
				{
					// Form 2, BEFORE
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, false);
				}
				
			| AFTER isfi=indexedSequenceForInsert
			
				{
					// Form 3, AFTER
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, true);
				}
		)

		{
			// Tree span
			//
			endPos($value);
		}	    
	    
	    ((SEMI)=>SEMI)?
	    
	;
	
// ----------------
// Insert seqeunce.
// Parse the syntax for an insert sequence specified by the 
// INSERT BEFORE and INSERT AFTER variants.
//
indexedSequenceForInsert

	returns [JFXExpression seq, JFXExpression idx]

	: primaryExpression 			
	
		{
			// Sequence expression
			//
			$seq = $primaryExpression.value;
		}
		
	  LBRACKET valueExpression RBRACKET
	  
	  	{
	  		// Index expressions
	  		//
	  		$idx = $valueExpression.value;
	  	}
	  		
 	;
 
// -----------------	
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
delete  

	returns [JFXExpression value]	// Delete returns a JFX Expression tree

	: DELETE e1=valueExpression

	   ( 
	   		  (FROM)=>FROM e2=valueExpression
	   		  	
	   		  	{
	   		  		$value = F.at(pos($DELETE)).SequenceDelete($e2.value,$e1.value);
	   		  	}
	   		  	
	   		| /* indexed and whole cases */
	   		
	   			{
	   				$value = F.at(pos($DELETE)).SequenceDelete($e1.value);
	   			}
	   			
	   )
	   
	   {
	   		// Tree span
	   		//
	   		endPos($value);
	   }
	   ((SEMI)=>SEMI)?
	;

// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
return
	: 'return' 
		(
			  valueExpression		

			  	(';')?
			  	
			| ';'			// Can't have a SEMI be optional here as we must eitehr consume

		)
	
	;
	
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
try
	: 'try' block 			
		(
		 	  f1=finallyClause
	   		| (
	   				catchClause
	   				
	   				{
	   					// Accumulate the catch clauses
	   					//
	   					caught.append($catchClause.value);
	   				}
	   		  )+ 
	   			
	   			( 
	   				f1=finallyClause
	   			)?   
	   	)

	;
	
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//
finallyClause
	: 'finally' block
	;
	
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause
	: 'catch' '(' formalParameter ')' block
	;
	
initializingExpression 

	: 'bind' valueExpression 
	
			(
				'with' 'inverse'
			)?
	
	| valueExpression
	;
	
// -----------
// expression.
// General expression parse and AST build.
//
valueExpression
	: if	
	| for   	

		{
			$value = $for.value;
		}
		
	| newExpression

		{
			$value = $newExpression.value;
		}
		
	| assignmentExpression

		{
			$value = $assignmentExpression.value;
		}
		
	| // Expressions can only declare local variables, hence we
	  // we parse any we find, but throw them out as a semantic
	  // error
	  {
	  	ePos = pos();
	  }
	  m=modifiers 
	  
	  	{
	  		if	($m.mods.flags != 0)
	  		{
	  			// Ignore the modifiers
	  			//
	  			$m.mods.flags = 0;
	  			
	  			// Issue the error
	  			//
	  			log.error(ePos, "javafx.cannot.modify.localvar");
	  			
	  		}
	  	}
	  	
	  	variableDeclaration [$m.mods]
	
		{
			$value = $variableDeclaration.value;
		}
	;

// ------------------------
// FOR statement/expression
//
for
	: 'for' 
		'(' 
		
			i1=inClause			
			(',' i2=inClause)* 
			
		')' 
		
		expression
				
			{
		 		$value = F.at(pos($FOR)).ForExpression(clauses.toList(), $expression.value);
			}
		
		{
			// Tree span
			//
			endPos($value);
		}
	;

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause
	: formalParameter 'in' se=valueExpression 
		(
			  'where' we=valueExpression	
			|
		)

	;
	
// -----------------------
// If Then Else expression
//
if 
	: 'if' '(' valueExpression  ')' 
	
		'then'?  expression 			
			(
				'else' expression	
			)?

	;
	
	

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}
	: lhs=assignmentOpExpression 
		(     
			  (EQ)=> EQ rhs=valueExpression
			  
			  	{
			  		// This is actually an assign
			  		//
			  		$value = F.at(rPos).Assign($lhs.value, $rhs.value);
			  		
			  		// Tree span
			  		//
			  		endPos($value);
			  	}
			  	
			|	// Just an expression without an assignment
				//
				{
					$value = $lhs.value;
				}
		)
	;
	
assignmentOpExpression

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: lhs=andExpression					
	  
		(     assignOp rhs=valueExpression
		
				{
					// AST for assignement
					//
					$value = F.at(rPos).Assignop($assignOp.op, $lhs.value, $rhs.value);
				}
				
           	| SUCHTHAT such=andExpression (TWEEN i=andExpression)?
           	
           		{
           			// AST FOR Interpolation
           			//
           			$value = F.at(rPos).InterpolateValue($lhs.value, $such.value, $i.value);
           		}
           	
	   		|	{ 
	   				// AST for expressions
	   				//
	   				$value = $lhs.value; 
	   			}	
	   )
	   
	   {
	   		// AST Span
	   		//
	   		endPos($value);
	   }
	;

// -----------------
// Assign operators
// All the operators that involve assignments.
//	
assignOp

	returns	[JavafxTag op]	// Returns the operation token that we find
	
	: PLUSEQ		{ $op = JavafxTag.PLUS_ASG; 			}
	| SUBEQ			{ $op = JavafxTag.MINUS_ASG;			}
	| STAREQ		{ $op = JavafxTag.MUL_ASG;              }
	| SLASHEQ		{ $op = JavafxTag.DIV_ASG;				}
	| PERCENTEQ
		{ 
			$op = JavafxTag.MOD_ASG;
			log.warning(pos($PERCENTEQ), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The operator \%= will not be supported in the JavaFX 1.0 release" );
		}
	;
	
// -------------
// AND opertator
// LL(k) AND precedence
//
andExpression

	returns [JFXExpression value] 	// Expression tree for AND
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	:	e1=orExpression
			
			{
				$value = $e1.value;
			}
	  		( 
	  			AND e2=orExpression
	  			
	  			{
	  				$value = F.at(rPos).Binary(JavafxTag.AND, $value, $e2.value);
	  				endPos($value);
	  			}
	  		)*
	;
	
// -----------
// OR operator
// LL(k) OR precedence
//
orExpression

	returns [JFXExpression value] 	// Expression tree for OR
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: e1=typeExpression

		{
			$value = $e1.value;
		}
	  	( 
	  		OR e2=typeExpression 
	  		
	  		{
	  			$value = F.at(rPos).Binary(JavafxTag.OR, $value, $e2.value);
	  			endPos($value);
	  		}
	  	)*
	;
	
// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: relationalExpression		

		(
			  INSTANCEOF itn=type
			
				{
					$value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
					endPos($value);
				}
				
			| AS atn=type
			
				{
					$value = F.at(pos($AS)).TypeCast($atn.rtype, $relationalExpression.value);
					endPos($value);
				}
			
			| 	{
					$value = $relationalExpression.value;
				}
	   )
	;

// -----------
// Relationals
// LL(k) precedence
//	
relationalExpression  

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: a1=additiveExpression	{ $value = $a1.value;	}
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			relOps   a2=additiveExpression
			  	
			  	{
			  		$value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
			  		endPos($value);
			  	}
		)* 
	;
	
// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

	: NOTEQ  { $relOp = JavafxTag.NE;	}
	| EQEQ   { $relOp = JavafxTag.EQ;	}
	| LTEQ   { $relOp = JavafxTag.LE;	}
	| GTEQ   { $relOp = JavafxTag.GE;	}
	| LT     { $relOp = JavafxTag.LT;	}
	| GT     { $relOp = JavafxTag.GT;	}
	;

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//	
additiveExpression 
	: m1=multiplicativeExpression	
		{ 
			$value = $m1.value; 
		}
		(
			
			
		    (arithOps)=>
		    
		    	{ rPos = pos(); }	// Use operator as position for AST
		    	
		    	arithOps   m2=multiplicativeExpression
		)* 
	;

// --------------------
// Arithmetic operators
//
arithOps
	: PLUS		{ $arithOp = JavafxTag.PLUS; 	}
	| SUB		{ $arithOp = JavafxTag.MINUS;	}
	;

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//	
multiplicativeExpression
	: u1=unaryExpression	{ $value = $u1.value; }
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			multOps u2=unaryExpression
				
				{
					$value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
					endPos($value);
				}
	   )* 
	;

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

	returns [JavafxTag multOp]	// Returns the JFX operator type
	
	: STAR    	{ $multOp = JavafxTag.MUL;	}
	| SLASH   	{ $multOp = JavafxTag.DIV;	}
	| PERCENT 	
			
		{
			$multOp = JavafxTag.MOD;
			log.warning(pos($PERCENT), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The remainder operator \% will be replaced by mod" );
		}	
             
	| MOD		{ $multOp = JavafxTag.MOD;	}
	;
	
// -----------------	
// Unary expressions
// LL(k) Precedence
//
unaryExpression

	returns [JFXExpression value] 	// Expression tree for unary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: se=suffixedExpression

		{
			$value = $se.value;
		}
		
	| INDEXOF		id=identifier
	
		{ 	
			$value = F.at(rPos).Indexof($id.value);
			endPos($value);
		}
		
	| unaryOps     	e=unaryExpression

		{
			$value = F.at(rPos).Unary($unaryOps.unOp, $e.value);
			endPos($value);
		}
	;
	
// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps

	returns [JavafxTag unOp]	// Returns the JFX operator type
	
	: SUB			{ $unOp = JavafxTag.NEG; }
	| NOT			{ $unOp = JavafxTag.NOT; }
	| SIZEOF		{ $unOp = JavafxTag.SIZEOF; }
	| PLUSPLUS		{ $unOp = JavafxTag.PREINC; }
	| SUBSUB		{ $unOp = JavafxTag.PREDEC; }
	| REVERSE		{ $unOp = JavafxTag.REVERSE; }
	;

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: pe=postfixExpression
		( 
			  { input.LT(-1).getType() != RBRACE }?=> PLUSPLUS
			  
			  	{
			  		$value = F.at(rPos).Unary(JavafxTag.POSTINC, $pe.value);
			  		endPos($value);
			  	}
			  	
			| { input.LT(-1).getType() != RBRACE }?=> SUBSUB
			
				{
					$value = F.at(rPos).Unary(JavafxTag.POSTDEC, $pe.value);
					endPos($value);
				}
				
			| { $value = $pe.value; }
		)
	;
	
postfixExpressionPartialFunctionInvocation
	: pe=primaryExpression	
	
		(  ( '(' expressionList ')' )
	   	)
	;
	
otherPostfixExpressionForms
	:
	;

postfixExpression 
	: pe=primaryExpression	
		( 
			  '.' 
				( 
					  n1=name
	         	)
			| '('  expressionList ')'
			| sequenceSelect
	   	)* 
	;

sequenceSelect
	: LBRACKET
				(
					  n2=name PIPE 
					  e1=valueExpression r3=RBRACKET
					| first=valueExpression
						(
							  r1=RBRACKET
	                    	| DOTDOT 
	                    		(
									  (LT  )? 
									  	(
									  		last=valueExpression
									  	)?
									  	
								)
	                      	  r2=RBRACKET
                    	)
             	)
	;

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//	
primaryExpression  
	: qualifiedName
	| objectLiteral
	| THIS
	| SUPER
	| se=stringExpression
	| be=bracketExpression		
	| block
	| literal		
	| fe=functionExpression
	| LPAREN e=valueExpression RPAREN
	| AT 
		LPAREN 
			TIME_LITERAL
		RPAREN 
		LBRACE 
			k=keyFrameLiteralPart 
		RBRACE
	;
	
// ------------
// Frame values
//  
keyFrameLiteralPart

	returns [ListBuffer<JFXExpression> exprs = new ListBuffer<JFXExpression>(); ]	// Gathers a list of expressions representing frame values

	: k1=valueExpression 			{ exprs.append($k1.value);	}
	
		(SEMI+
		
			k2=valueExpression		{ exprs.append($k2.value);	}
		)* SEMI*
    ;

// -------------------
// Anonymous functions
//
functionExpression

	returns [JFXExpression value] 	// Expression tree for anonymous function

	: FUNCTION formalParameters typeSpecifier block
	
		{
			// JFX AST
			//
			$value = F.at(pos($FUNCTION)).FunctionValue
								(
									$typeSpecifier.rtype, 
									$formalParameters.params.toList(),
									$block.value
								);
								
			// Tree span
			//
			endPos($value);
		}
	;
	
// ---
// NEW
//
newExpression
	: NEW typeName expressionListOpt
	
		{
			$value = F.at(pos($NEW)).InstanciateNew($typeName.value, $expressionListOpt.args.toList());
			endPos($value);
		}
	;

// ---------------
// Object literals
//
objectLiteral
	:   qualifiedName
			'{'   

			((',')|(';'))*	
		(		
			objectLiteralPart 
			((',')|(';'))*	// Separators are optional and just syntactic sugar
			
			
		)*		// May be no elements in the object literal, just {}
	
		'}'	
	;

// Individual components of an object literal
//
objectLiteralPart
	: variableOverrideDeclaration
	| variableDeclaration 
	| functionDefinition	
	| objectLiteralInit
    ;
  
// --------------------------     	
// Object literal initializer
//	
objectLiteralInit
	: name ':'  initializingExpression
	;

// -------	
// Strings
// JavaFX string expresoins are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time
//    over which the script author then has unambiguous control over
//    leading spaces, can explictly insert new lines, and can comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leades to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Individual compound parts cannot be translated individually;
//
stringExpression 
	: (
		  (
			// Translation key is optional
		  	//
		  	TRANSLATION_KEY	{ translationKey = $TRANSLATION_KEY.text; } 
		  )?
	
			// We must find at least one compund element to the string
			//
			strCompoundElement [ strexp ]
			
			(
				// After the first element, there may be any number of additional
				// elements, including zero. We must force the parser to take
				// the righteous path for syntactically correct constructs, then
				// error out semantically on anything else.
				//
				   strCompoundElement [ strexp ]
			)*
	  )
	;
	
// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<JFXExpression> strexp ]
	
	: STRING_LITERAL		
	| qlsl 			[ strexp ]
	;
	
	
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<JFXExpression> strexp]
	: 	//QUOTE_LBRACE_STRING_LITERAL	
		QUOTE
	  	( STRING '{'
		FORMAT_STRING_LITERAL? valueExpression '}'  )+
	  
	  	// The last component of the {} enclosing string literal
	  	//
	  	//RBRACE_QUOTE_STRING_LITERAL
	  	STRING QUOTE
	;
QUOTE 
	:	 ;
STRING 
	:	 ;	
// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<JFXExpression> strexp]
	: //RBRACE_LBRACE_STRING_LITERAL 
		'}' STRING '{'
		formattedExpression
	;
	
formattedExpression 
	: FORMAT_STRING_LITERAL? valueExpression
	;
	
// ---------------------------
// Sequence
// Which is a [] enclosed expression list
//
bracketExpression
	: LBRACKET   
	
		( 	e1=valueExpression
				{
					seqexp.append($e1.value);
				}
		     	(
		     		COMMA*
		     		  (
		     			
		     				(
		     					e2=valueExpression
		     						{
		     							seqexp.append($e2.value);
		     						}
		     				)
		     				COMMA*
		     		  )*
	                    
	                    {
	                    	// Explicit sequence detected
	                    	//
	                    	$value = F.at(rPos).ExplicitSequence(seqexp.toList());
	                    	endPos($value);
	                    }
	                    
		     		| DOTDOT
		     			(LT { haveLT = true; })? 
		     			dd=valueExpression
		     	    	( STEP st=valueExpression { stepEx = $st.value; } )?
		     	    	
		     	    	{
		     	    		$value = F.at(pos($DOTDOT)).RangeSequence($e1.value, $dd.value, stepEx, haveLT);
		     	    		endPos($value);
		     	    	}
		     	)
		     	
		     |  // Empty sequence 
		     	{
		     		 $value = F.at(rPos).EmptySequence();
		     		 endPos($value);
		     	}
	    )
	  RBRACKET
	;

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList
	: e1=valueExpression
		(
			',' 	(
						e2=valueExpression
					)
		)*
	|
	;

// ------------------------
// Optional expression list
// For the moment this is only used by New....
//
expressionListOpt
	: (LPAREN)=>LPAREN expressionList RPAREN
		{
			$args = $expressionList.args;
		}
		
	|	// Was not present
	;


// -----
// Types
//
type

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: typeName cardinality
	
		{
			$rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
			endPos($rtype);
		}
		
 	| FUNCTION 
 		LPAREN 
 			typeArgList
		RPAREN 
		
			ret=typeSpecifier 
          	cardinality	//TODO: this introduces an ambiguity: return cardinality vs type cardinality
          	
		{
			$rtype = F.at(rPos).TypeFunctional($typeArgList.ptypes.toList(), $ret.rtype, $cardinality.ary);
			endPos($rtype);
		}

 	| STAR cardinality
 	
 		{
 			$rtype = F.at(rPos).TypeAny($cardinality.ary);
 			endPos($rtype);
 		}
 	;

// ----------------------------
// A list of types as arguments
//
typeArgList
 	
 returns [ListBuffer<JFXType> ptypes = ListBuffer.<JFXType>lb(); ]
 
 	: t1=typeArg
 	
 		{
 			ptypes.append($t1.rtype);
 		}
 		 
 		(
 			COMMA 
 			(
 				t2=typeArg
 				
 				{
 					ptypes.append($t2.rtype);
 				}
 			)?
 		)*
 	|
	;

// -------------------------
// Individual typed argument
//
typeArg 

	returns [JFXType rtype]

 	: (
 		(
 			name	// TODO: Check this, it is currently ignored for AST and does not
 					//       look quite right.
 		)? 
 			COLON
 	  )?
 	  
 	  type
 	
 		{
 			$rtype = $type.rtype;
 		}
 	;
 	
 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeSpecifier	
 	: ':' type
 	| // Untyped element, the AST needs to reflect that

 	;
 	
// -------------------------
// Array indicator for types
//
cardinality
	: '[]'
	
	|	
	;

// ----------
// Named type

// Possibly a generic
//
typeName

	returns [JFXExpression value]

@init
{
	// Accumulate any generic arguments
	//
	ListBuffer<JFXExpression> exprbuff = ListBuffer.<JFXExpression>lb();
}

	: qualifiedName 		
		(
			  LT ga1=genericArgument 	{ exprbuff.append($ga1.value); }
			  	
			  		(
			  			COMMA
			  				(
			  					ga2=genericArgument
			  				
			  							{ exprbuff.append($ga2.value); }
			  				)?
			  		)* 
			  GT
			  
			  {
			  	// AST for generic
			  	//
			  	// TODO: Implement this?
			  	//
			  	log.error(pos($LT), "javafx.generalerror", "Java generic type declarations are not currently supported");
			  }
			  
			|	// Non generic
				{
					$value = $qualifiedName.value;
				}
		)
	;
	
genericArgument

	returns [JFXExpression value]

@init 
{
	BoundKind 		bk 		= BoundKind.UNBOUND;
	JFXExpression 	texpr 	= null; 
}

	: typeName	{ $value = $typeName.value; }
	
	| QUES 
		(  
			( 
				  EXTENDS 		{ bk = BoundKind.EXTENDS; 	}
		  		| SUPER			{ bk = BoundKind.SUPER; 	}
		  	) 
		 	typeName			{ texpr = $typeName.value; }
		)?
		
		{
			// TODO: NYI - Remove or implement?
		}
	;

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal

	returns [JFXExpression value]
	
@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: 
		(
			 DECIMAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($DECIMAL_LITERAL.text, 10));
				}
				
			| OCTAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($OCTAL_LITERAL.text, 8));
				}
			
			| HEX_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($HEX_LITERAL.text, 16));
				}
				
		    | TIME_LITERAL
		    
		    	{
		    		$value = F.at(rPos).TimeLiteral($TIME_LITERAL.text);
		    	}
		    	
			| FLOATING_POINT_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.DOUBLE, Double.valueOf($FLOATING_POINT_LITERAL.text));
				}
				
			| TRUE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 1);
				}
				
			| FALSE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 0);
				}
				
			| NULL
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOT, null);
				}
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;

// -------------------------	
// Qualified (possibly) name
//
qualifiedName

	returns [JFXExpression value]
	
	: n1=name
		{
			$value = F.at($n1.pos).Ident($n1.value);
			endPos($value, $n1.pos + $n1.value.length());
		}
		( 
			(DOT)=> DOT n2=name
			
				{
					$value = F.at(pos($DOT)).Select($value, $n2.value);
					endPos($value); 
				}
			
		)*  
	;

// -----------------------
// ID
// Basic identifier parse
//
identifier

	returns [JFXIdent value]

	: n1=name
		{
			$value = F.at($n1.pos).Ident($n1.value);
						endPos($value, $n1.pos + $n1.value.length());
		}
	;

// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it coudl just be a tag or function name etc.
//
name 

	returns [Name value, int pos]
	
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = pos($IDENTIFIER); 
		}
						
	;
